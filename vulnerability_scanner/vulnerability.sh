#!/bin/bash
# author: andreaswendlandt
# desc: vulnerability scanner 
# last modified: 31.05.2022

# ensure this script started with root privileges
if [[ $(id -u) -ne 0 ]]; then
    echo "ERROR: This script must be run as root"
    exit 1
fi

# logging
logfile="/var/log/$(basename "$0").log"
mylog(){
    echo "$(date)" "$@" >>"${logfile}"
}

# ensure we are the only running instance
lock_err(){
    mylog "ERROR, another instance is already running, aborting!!!"
    exit 1
}

pidfile="/var/run/$(basename "$0")"
exec 300>"${pidfile}"
flock -n 300 || lock_err
pid=$$
echo "${pid}" 1>&300

# required packages: nmap, flock, iproute2, aptitude, deborphan
required_packages=(nmap flock iproute2 aptitude deborphan)
max=${#required_packages[*]}
i=0
packages_not_present=""
while (( i < max )); do
    if ! dpkg -l | grep "${required_packages[$i]}" >/dev/null 2>&1 && ! command -v "${required_packages[$i]}" >/dev/null 2>&1; then
        packages_not_present="$packages_not_present ${required_packages[$i]}"
    fi
    i=$((i+1))
done

not_installed=0
if [[ -n "$packages_not_present" ]]; then
    while true; do
        read -p -r "Should i install the missing package(s)${packages_not_present}?: yes/no " answer
        if [[ $answer == "yes" ]]; then
            apt-get update >/dev/null && apt-get install -y "${packages_not_present}" >/dev/null
            mylog "package ${packages_not_present installed}"
            not_installed=1
            break
        elif [[ "${answer}" == "no" ]]; then
            mylog "WARNING, ${packages_not_present} missing on this System and will not be installed, skipping the dedicated section and not doing a full scan"
            not_installed=2
            break
        else
            echo "${answer} is not a valid answer, please enter yes or no."
            continue
        fi
    done
fi

summary="\n##### SUMMARY OF ${HOSTNAME} FROM $(date) #####"
###################
# network section #
###################
# open ports
if [[ "$not_installed" -eq "2" ]] && echo "${packages_not_present}" | grep nmap >/dev/null 2>&1; then
    summary="${summary}\n\nskipping the open port section as nmap was not installed!"
else
    open_ports=$(nmap -v localhost | grep -E '^[[:digit:]]' | awk '$2 ~ open {print $1}')
    summary="${summary}\n\nthese ports are open: \n${open_ports}"
fi

# network devices with promiscuous mode
network_devices=$(netstat -i | while read -r line; do awk '$12 ~ /P/{print $1}'; done)
if [[ -n "${network_devices}" ]]; then
    summary="${summary}\n\nthese network devices are set on promiscuous Mode:\n${network_devices}"
fi

# established network connections
current_connections=$(ss -tu state established)
if [[ $(echo "${current_connections}" | wc -l) -eq 1 ]]; then
    summary="${summary}\n\nno network connections are established in the moment."
elif [[ $(echo "${current_connections}" | wc -l) -gt 1 ]]; then 
    summary="${summary}\n\nthese network connections are established in the moment:\n${current_connections}"
else
    summary="${summary}\n\ncould not determine the current connections, please check manually!"
fi
###################
# package section #
###################
# packages that can be upgraded
if [[ "${not_installed}" -eq "2" ]] && echo "${packages_not_present}" | grep aptitude >/dev/null 2>&1; then
    summary="${summary}\n\nskipping the upgradable package section as aptitude was not installed!"
else
    upgradable_packages=$(aptitude -q -F %p --disable-columns search "~U")
    if [[ -n "${upgradable_packages}" ]]; then
        summary="${summary}\n\nthese packages can be upgraded:\n${upgradable_packages}"
    fi
fi

# packages on hold
packages_onhold=$(dpkg --get-selections | awk '$2 == "hold" { print $1 }')
if [[ -n "${packages_onhold}" ]]; then
    summary="${summary}\n\nthese packages are set on hold:\${packages_onhold}"
fi

# orphaned packages
if [[ "$not_installed" -eq "2" ]] && echo "${packages_not_present}" | grep deborphan >/dev/null 2>&1; then
    summary="${summary}\n\nskipping the orphaned package section as deborphan was not installed!"
else
    orphaned_packages=$(deborphan)
    if [[ -n "${orphaned_packages}" ]]; then
        summary="${summary}\n\nthese packages are orphaned and can be removed:\n${orphaned_packages}"
    fi
fi

################
# user section #
################
# users with login shells
users_with_login_shells=$(getent passwd | awk -F ':' '$7 !~ /(nologin)|(false)|(sync)/ {print $1}')
summary="${summary}\n\nthese users have login shells:\n${users_with_login_shells}"

# user without password
accounts_without_password="$(for user in ${users_with_login_shells}; do 
    grep "${user}" /etc/shadow | awk -F ':' '$2 ~ /(\!)|(\*)/ {print $1}'
done)"
if [[ -n "${accounts_without_password}" ]]; then
    summary="${summary}\n\nthese accounts have an empty password:\n${accounts_without_password}"
fi

# ssh keys
home_dirs=""
for user in ${users_with_login_shells}; do
    home_dirs="${home_dirs} $(getent passwd | grep "${user}" | awk -F ':' '{print $6}')"
done

ssh_keys=""
for dir in ${home_dirs}; do
    file_to_check=$(find "${dir}" -name authorized_keys 2>/dev/null)
    if [[ -n ${file_to_check} ]]; then
        ssh_keys="${ssh_keys} $(awk '{print $3}' "${file_to_check}")"
    fi
done
keys=$(for key in ${ssh_keys}; do
    echo "${key}"
done)
summary="${summary}\n\nthese ssh keys are stored on this system:\n${keys}"

# more than one root account
root_accounts=$(awk -F ':' '$3 == 0 {print $1}' /etc/passwd)
if [[ "$(echo "${root_accounts}" | wc -w )" -gt 1 ]]; then
    summary="${summary}\n\nthere is more then one root account:\n${root_accounts}"
fi 

# ssh root login enabled
if ! [[ $(sshd -T | grep -i permitrootlogin | awk '{print $2}') == "no" ]]; then
    summary="${summary}\n\n!root ssh login is enabled on this system!"
fi  

################
# file section #
################
# files with setuid and/or setgid bit set
files_with_suid_and_sgid=$(find / -type f -perm /6000 2>/dev/null)
summary="${summary}\n\nthese files have the suid and/or the sgid bit set:\n${files_with_suid_and_sgid}"

# files with no ownership
files_with_no_ownership=$(find / -nouser 2>/dev/null)
if [[ -n "$files_with_no_ownership" ]]; then
   summary="${summary}\n\nthese files have no ownership:\n${files_with_no_ownership}"
fi 

# files with no group associated to
files_with_no_group=$(find / -nogroup 2>/dev/null)
if [[ -n "${files_with_no_group}" ]]; then
   summary="${summary}\n\nthese files have no group associated to:\n${files_with_no_group}"
fi

#################
# mount section #
#################
# mountpoints with suspicious mount options
suspicious_mountpoints=$(mount | while read -r line; do echo "${line}" | sed -e 's/,/ /g' -e 's/)\|(//g' | awk '/( dev | exec | suid | defaults )/{print $3}'; done)
if [[ -n "$suspicious_mountpoints" ]]; then
    summary="${summary}\n\nthese mounted filesystems have suspicious mount options:\n${suspicious_mountpoints}"
fi

# /proc visibility
if ! mount | awk '$1 ~ /proc/ {print $0}' | grep 'hidepid=2' >/dev/null; then
    summary="${summary}\n\nthe whole /proc is visible for all!"
fi

####################
# services section #
####################
# services running
services_currently_running=$(service --status-all | awk '$2 ~ /\+/ {print $4}')
summary="${summary}\n\nthese services are currently running:\n${services_currently_running}"

# services starting at boot
services_starting_at_boot=$(find /etc/rc[1-5].d/S* -type l -name 'S*' | sed -e 's/\/etc\/rc[1-5]\.d\/S..//' | sort | uniq)
summary="${summary}\n\nthese services are starting at boot:\n${services_starting_at_boot}"

echo -e "$summary"
