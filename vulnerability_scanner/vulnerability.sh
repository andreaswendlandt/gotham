#!/bin/bash
# author: guerillatux
# desc: vulnerability scanner 
# last modified: 20.1.2019

# ensure this script started with root privileges
if [ $(id -u) -ne 0 ]; then
    echo "ERROR: This script must be run as root"
    exit 1
fi

# logging
logfile=/var/log/$(basename $0).log
mylog(){
    echo "$(date) $@" >>$logfile
}

# ensure we are the only running instance
lock_err(){
    mylog "ERROR, another Instance is already running, aborting!!!"
    exit 1
}

pidfile="/var/run/$(basename $0)"
exec 300>$pidfile
flock -n 300 || lock_err
pid=$$
echo $pid 1>&300

# required packages: nmap, flock, iproute2, aptitude, deborphan
required_packages=(nmap flock iproute2 aptitude deborphan)
max=${#required_packages[*]}
i=0
packages_not_present=""
while (( i < max )); do
    if ! dpkg -l | grep ${required_packages[$i]} >/dev/null 2>&1 && ! which ${required_packages[$i]} >/dev/null 2>&1; then
        packages_not_present="$packages_not_present ${required_packages[$i]}"
    fi
    i=$(expr $i + 1)
done

not_installed=0
if ! [ -z "$packages_not_present" ]; then
    while true; do
        read -p "Should i install the missing Package(s)${packages_not_present}?: yes/no " answer
        if [[ $answer = "yes" ]]; then
            apt-get update >/dev/null && apt-get install -y $packages_not_present >/dev/null
            mylog "Package $packages_not_present installed"
            not_installed=1
            break
        elif [[ $answer = "no" ]]; then
            mylog "WARNING, $packages_not_present missing on this System and will not be installed, skipping the dedicated Sections and not doing a full scan"
            not_installed=2
            break
        else
            echo "$answer is not a valid Answer, please enter yes or no."
            continue
        fi
    done
fi

summary="\n##### SUMMARY OF $HOSTNAME FROM $(date) #####"
###################
# network section #
###################
# open ports
if [ "$not_installed" -eq "2" ] && echo "$packages_not_present" | grep nmap >/dev/null 2>&1; then
    summary="$summary\n\nSkipping the Open Port Section as nmap was not installed!"
else
    open_ports=$(nmap -v localhost | egrep '^[[:digit:]]' | awk '$2 ~ open {print $1}')
    summary="$summary\n\nThese Ports are open: \n$open_ports"
fi

# network devices with promiscuous mode
network_devices=$(netstat -i | while read line; do awk '$12 ~ /P/{print $1}'; done)
if ! [ -z "$network_devices" ]; then
    summary="$summary\n\nThese Network Devices are set on promiscuous Mode:\n$network_devices"
fi

# established network connections
current_connections=$(ss -tu state established)
if [ $(echo "$current_connections" | wc -l) -eq 1 ]; then
    summary="$summary\n\nNo Network Connections are established in the Moment."
elif [ $(echo "$current_connections" | wc -l) -gt 1 ]; then 
    summary="$summary\n\nThese Network Connections are established in the Moment:\n$current_connections"
else
    summary="$summary\n\nCould not determine the current Connections, Please check manually!!!"
fi
###################
# package section #
###################
# packages that can be upgraded
if [ "$not_installed" -eq "2" ] && echo "$packages_not_present" | grep aptitude >/dev/null 2>&1; then
    summary="$summary\n\nSkipping the upgradable Package Section as aptitude was not installed!"
else
    upgradable_packages=$(aptitude -q -F%p --disable-columns search "~U")
    if ! [ -z "$upgradable_packages" ]; then
        summary="$summary\n\nThese Packages can be upgraded:\n$upgradable_packages"
    fi
fi

# packages on hold
packages_onhold=$(dpkg --get-selections |awk '$2 == "hold" { print $1 }')
if ! [ -z "$packages_onhold" ]; then
    summary="$summary\n\nThese Packages are set on Hold:\$packages_onhold"
fi

# orphaned packages
if [ "$not_installed" -eq "2" ] && echo "$packages_not_present" | grep deborphan >/dev/null 2>&1; then
    summary="$summary\n\nSkipping the orphaned Package Section as deborphan was not installed!"
else
    orphaned_packages=$(deborphan)
    if ! [ -z "$orphaned_packages" ]; then
        summary="$summary\n\nThese Packages are orphaned and can be removed:\n$orphaned_packages"
    fi
fi

################
# user section #
################
# users with login shells
users_with_login_shells=$(getent passwd | awk -F\: '$7 !~ /(nologin)|(false)|(sync)/ {print $1}')
summary="$summary\n\nThese Users have Login Shells:\n$users_with_login_shells"

# user without password
accounts_without_password="$(for user in $users_with_login_shells; do 
    grep $user /etc/shadow | awk -F\: '$2 ~ /(\!)|(\*)/ {print $1}'
done)"
if ! [ -z "$accounts_without_password" ]; then
    summary="$summary\n\nThese Accounts have an empty Password:\n$accounts_without_password"
fi

# ssh keys
home_dirs=""
for user in $users_with_login_shells; do
    home_dirs="$home_dirs $(getent passwd | grep $user | awk -F\: '{print $6}')"
done

ssh_keys=""
for dir in $home_dirs; do
    file_to_check=$(find $dir -name authorized_keys 2>/dev/null)
    if ! [ -z $file_to_check ]; then
        ssh_keys="$ssh_keys $(cat $file_to_check | awk '{print $3}')"
    fi
done
keys=$(for key in $ssh_keys; do
    echo "$key"
done)
summary="$summary\n\nThese ssh Keys are stored on this System:\n$keys"

# more than one root account
root_accounts=$(awk -F\: '$3 == 0 {print $1}' /etc/passwd)
if [ $(echo "$root_accounts" | wc -w ) -gt 1 ]; then
    summary="$summary\n\nThere is more then one root Account:\n$root_accounts"
fi 

# ssh root login enabled
if ! [ $(sshd -T | grep -i permitrootlogin | awk '{print $2}') == "no" ]; then
    summary="$summary\n\n!!!Root SSH Login is enabled on this System!!!"
fi  

################
# file section #
################
# files with setuid and/or setgid bit set
files_with_suid_and_sgid=$(find / -type f -perm /6000 2>/dev/null)
summary="$summary\n\nThese Files have the SUID and/or the SGID Bit set:\n$files_with_suid_and_sgid"

# files with no ownership
files_with_no_ownership=$(find / -nouser 2>/dev/null)
if ! [ -z $files_with_no_ownership ]; then
   summary="$summary\n\nThese Files have no Ownership:\n$files_with_no_ownership"
fi 

# files with no group associated to
files_with_no_group=$(find / -nogroup 2>/dev/null)
if ! [ -z $files_with_no_group ]; then
   summary="$summary\n\nThese Files have no Group associated to:\n$files_with_no_group"
fi

#################
# mount section #
#################
# mountpoints with suspicious mount options
suspicious_mountpoints=$(mount | while read line; do echo $line | sed -e 's/,/ /g' -e 's/)\|(//g' | awk '/( dev | exec | suid | defaults )/{print $3}'; done)
if ! [ -z "$suspicious_mountpoints" ]; then
    summary="$summary\n\nThese mounted Filesystems have suspicious Mount Options:\n$suspicious_mountpoints"
fi

# /proc visibility
if ! mount | awk '$1 ~ /proc/ {print $0}' | grep 'hidepid=2' >/dev/null; then
    summary="$summary\n\nThe whole /proc is visible for all!!!"
fi

####################
# services section #
####################
# services running
services_currently_running=$(service --status-all | awk '$2 ~ /\+/ {print $4}')
summary="$summary\n\nThese services are currently running:\n$services_currently_running"

# services starting at boot
services_starting_at_boot=$(ls -la /etc/rc[1-5].d/S* | awk '{print $9}' | sed -e 's/\/etc\/rc[1-5]\.d\/S..//' | sort | uniq)
summary="$summary\n\nThese Services are starting at Boot:\n$services_starting_at_boot"

echo -e "$summary"
