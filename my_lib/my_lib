#!/bin/bash
## this "library" is a little collection of functions that can be used again and again in shell scripts
## author: andreaswendlandt
## last modified: 21.05.2022

# function for checking if a variable is an integer one

is_int(){
    if [[ "${1}" =~ ^[[:digit:]]+$ ]]; then
        return 0
    else
        return 1
    fi
}

# function for checking if a variable is empty
is_empty(){
    if [[ -z "${1}" ]]; then
        return 0
    else
        return 1
    fi
}

# function for checking if a variable consists only of letter characters
is_alpha(){
    if [[ -z "${1//[[:alpha:]]/}" ]]; then
        return 0
    else
        return 1
    fi
}

# function for checking if a variable has specialchars 
has_specialchars(){
    if [[ -z "${1//[[:alnum:]]/}" ]]; then
        return 1
    else
        return 0
    fi
}

# function for checking if a variable consists only of integers and dots(like most versions)
is_version(){
    no_digits="${1//[[:digit:]]/}"
    if [[ -z "${no_digits//./}" ]]; then
        return 0
    else
        return 1
    fi
}

# logging function - logs to /tmp/<script-name.log>
my_logfile=/tmp/$(basename "${0}").log
my_log() {
    echo "$(date)" "$@" >> "${my_logfile}"
}

# flock - ensure that only one instance of your script is running
# if you try to run your script while antother one is running it will abort
lock_err(){
    echo "ERROR, another instance of $(basename "${0}") is already running - aborting!!!"
    exit 1
}
my_flock(){
    pidfile="/tmp/$(basename "${0}").pid"
    exec 300>"${pidfile}"
    flock -n 300 ||  lock_err 
    pid=$$
    echo "${pid}" 1>&300
}

# 'config grep' - grep in files, get 3 possible return values, your search pattern was found - you get a "match"
# your search pattern was not found - you get a "no occurence" or and that is different to the regular grep
# you get an "outcommented" if the line of the match starts with a '#' or a ';'
config_grep(){
    if [[ $# -ne 2 ]]; then
        echo error: 2 parameters are needed for "${FUNCNAME[@]}"
        echo USAGE: "${FUNCNAME[@]}" \'search pattern\' \'search file\'
        return 1
    fi
    if [[ -f ${2} ]]; then
        result=$(grep -i "${1}" "${2}" 2>/dev/null | awk '{if (substr($1,1,1) ~ /#|;/) {print "outcommented"} else {print "match"}}')
        if [[ -z ${result} ]]; then
            result="no occurence"
        fi
        echo "${result}"
    else
        echo "file \"${2}\" does not exist"
        return 1
    fi
}

# function for checking if the script was started with root privileges
started_as_root(){
    if [[ $(id -u) -eq 0 ]]; then
        return 0
    else
        return 1
    fi
}

# function for checking if a variable is a valid ipv4 address
is_ipv4(){
    if echo "${1}" | grep -E -q '\b((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b'; then
        return 0
    else
        return 1
    fi
}

# function for checking if a variable is a float
is_float(){
    if [[ $(echo "${1}" | grep -o '\.'| wc -l) -eq 1 ]]; then
        no_digits="${1//[[:digit:]]/}"
        if [[ -z "${no_digits//./}" ]]; then
            return 0
        else
            return 1
        fi
    else
        return 1
    fi
}

# function for checking for lower letters in a string
has_lower_letter(){
    no_lower="${1//[[:lower:]]/}"
    if [[ "${1}" == "${no_lower}" ]]; then
        return 1
    else
        return 0
    fi
}

# function for checking for upper letters in a string
has_upper_letter(){
    no_upper="${1//[[:upper:]]/}"
    if [[ "${1}" == "${no_upper}" ]]; then
        return 1
    else
        return 0
    fi
}

# function for checking for integers in a string
has_int(){
    if [[ "${1}" =~ [[:digit:]] ]]; then
        return 0
    else
        return 1
fi
}

# color output
echo_red(){
        echo -e "$(tput setaf 1)$*"
}

echo_green(){
        echo -e "$(tput setaf 2)$*"
}

echo_yellow(){
        echo -e "$(tput setaf 3)$*"
}

echo_blue(){
        echo -e "$(tput setaf 4)$*"
}

# check if a branch has a remote
check_remote_branch(){
    if git ls-remote --exit-code --heads origin refs/heads/"${1}" >/dev/null; then
        return 0
    else
        return 1
    fi
}
